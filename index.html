<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>A Gift for Ms. Ruby Lieu</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body, html { 
            height: 100%; margin: 0; padding: 0; 
            overflow: hidden; background-color: #a2d2ff; 
            touch-action: none;
        }
        canvas { 
            display: block; position: absolute; 
            top: 0; left: 0; z-index: 1; 
        }
        .ui-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center; text-align: center;
            z-index: 100; pointer-events: none;
        }
        .content { 
            color: white; 
            font-family: 'Press Start 2P', cursive;
            max-width: 95%;
        }
        /* THAY ĐỔI CSS: Cỡ chữ đã được làm nhỏ lại */
        h1 { 
            font-size: clamp(0.9rem, 4vw, 1.5rem); /* <-- Chữ nhỏ hơn */
            margin: 0;
            line-height: 1.4;
            animation: text-glow 3s infinite alternate;
        }
        p { 
            font-size: clamp(0.7rem, 3vw, 1.1rem); /* <-- Chữ nhỏ hơn */
            margin-top: 12px; /* <-- Giảm khoảng cách */
            opacity: 0.9; 
            letter-spacing: 1px;
        }
        @keyframes text-glow {
            from { text-shadow: 2px 2px 0 #c78298, 4px 4px 0 #a8647a, 0 0 10px #ffc8dd; }
            to { text-shadow: 2px 2px 0 #c78298, 4px 4px 0 #a8647a, 0 0 20px #ffc8dd, 0 0 35px #ffc8dd; }
        }
    </style>
</head>
<body>
    <canvas id="gardenCanvas"></canvas>
    <div class="ui-container">
        <div class="content">
            <h1>Wishing you all the best</h1>
            <p>Ms. Ruby Lieu</p>
        </div>
    </div>

    <script>
        // PHẦN SCRIPT GIỮ NGUYÊN NHƯ CŨ
        const canvas = document.getElementById('gardenCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        let width, height;
        const pixelSize = 3;
        const sceneWidthMultiplier = 4;

        const palette = { sky_top: '#a2d2ff', sky_bottom: '#fbc4d8', sun: '#ffee99', mountain_far: '#d4b2d8', ground: '#ffc8dd', ground_dark: '#f4b2d2', tree_trunk: '#a56a57', tree_leaves: '#ff99c8', tree_leaves_dark: '#f080b4', cloud_base: '#ffffff', cloud_shadow: '#e0e0e0', heart: '#ff4d6d', flower_pink: '#ff8fab', flower_yellow: '#ffd966', flower_stem: '#80bfa0', flower_leaf: '#76c893', butterfly_wing: '#ffca3a', butterfly_body: '#8d6e63' };
        const sprites = { flower: { c:[palette.flower_pink, palette.flower_yellow, palette.flower_stem, palette.flower_leaf], m:[[0,2,0],[4,1,4],[0,3,0]]}, heart: { c:[palette.heart], m:[[0,1,0,1,0],[1,1,1,1,1],[0,1,1,1,0],[0,0,1,0,0]]}, butterfly: { c:[palette.butterfly_wing, palette.butterfly_body], frames: [ [[0,2,0],[1,2,1],[0,1,0]], [[1,0,1],[0,2,0],[1,0,1]] ] } };

        let layers = [];
        let bobAngle = 0, frameCount = 0;

        function drawProceduralHills(item) {
            ctx.fillStyle = item.color; ctx.beginPath(); ctx.moveTo(Math.round(item.x), Math.round(item.y));
            for(let i=0; i<item.points.length; i++) {
                const p = item.points[i], yBob = Math.sin(item.bob + bobAngle * 0.2 + i) * 10;
                ctx.quadraticCurveTo(Math.round(item.x + p.cpx), Math.round(item.y + p.cpy + yBob), Math.round(item.x + p.x), Math.round(item.y + p.y));
            }
            ctx.lineTo(Math.round(item.x + item.w), height); ctx.lineTo(Math.round(item.x), height); ctx.closePath(); ctx.fill();
        }

        function drawProceduralCloud(item) {
            for(const circle of item.circles) {
                const x = Math.round(item.x + circle.x), y = Math.round(item.y + circle.y + Math.sin(item.bob + bobAngle) * 5);
                ctx.fillStyle = circle.shadow ? palette.cloud_shadow : palette.cloud_base;
                ctx.beginPath(); ctx.arc(x, y, circle.r, 0, Math.PI * 2); ctx.fill();
            }
        }

        function drawProceduralTree(item) {
            const yBob = Math.sin(item.bob + bobAngle) * pixelSize * 3;
            ctx.save(); ctx.translate(Math.round(item.x), Math.round(item.y + yBob)); ctx.scale(item.flip, 1);
            const s = pixelSize * item.scale;
            ctx.fillStyle = palette.tree_trunk; ctx.fillRect(s*2, s*8, s*2, s*5);
            ctx.fillStyle = palette.tree_leaves_dark; ctx.beginPath(); ctx.arc(s*3, s*4, s*5, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = palette.tree_leaves; ctx.beginPath(); ctx.arc(s*3, s*2.5, s*4.5, 0, Math.PI*2); ctx.fill();
            ctx.restore();
        }
        
        function drawSprite(item) {
            const sprite = sprites[item.type];
            const yBob = Math.sin(item.bob + bobAngle) * pixelSize * 2;
            const flutter = item.type === 'butterfly' ? Math.sin(item.bob + bobAngle * 2) * 15 : 0;
            const frame = item.type === 'butterfly' ? Math.floor(frameCount / 10) % sprite.frames.length : 0;
            const matrix = sprite.frames ? sprite.frames[frame] : sprite.m;
            const scaledPixelSize = pixelSize * item.scale;
            ctx.save();
            ctx.translate(Math.round(item.x), Math.round(item.y + yBob + flutter));
            ctx.scale(item.flip, 1);
            for(let r=0; r < matrix.length; r++){
                for(let c=0; c < matrix[r].length; c++){
                    if(matrix[r][c] > 0) {
                        ctx.fillStyle = sprite.c[matrix[r][c]-1];
                        ctx.fillRect(c*scaledPixelSize, r*scaledPixelSize, scaledPixelSize, scaledPixelSize);
                    }
                }
            }
            ctx.restore();
        }

        function createScene() {
            layers = [ { items: [], speed: 10 }, { items: [], speed: 20 }, { items: [], speed: 80 }, { items: [], speed: 120 }, { items: [], speed: 180 }];
            const groundLevel = height - 60; const sceneWidth = width * sceneWidthMultiplier;
            
            const isMobile = window.innerWidth < 768;
            const hillCount = isMobile ? 10 : 20;
            const cloudCount = isMobile ? 15 : 25;
            const sceneryCount = isMobile ? 120 : 250;
            const butterflyCount = isMobile ? 5 : 10;
            
            for(let i=0; i < hillCount; i++) {
                const item = { isHill: true, color: palette.mountain_far, x: i * (sceneWidth/hillCount), y: groundLevel-100, w: sceneWidth/hillCount + 2, bob: Math.random()*Math.PI*2, points:[] };
                for(let j=0; j<3; j++) item.points.push({x: item.w*(j+1)/3, y:-Math.random()*60, cpx: item.w*j/3 + 20, cpy:-Math.random()*80});
                layers[0].items.push(item);
            }
            for (let i = 0; i < cloudCount; i++) {
                const item = { isCloud: true, x: Math.random()*sceneWidth, y: Math.random()*height*0.4, bob: Math.random()*Math.PI*2, circles:[] };
                for(let j=0; j<5; j++) item.circles.push({x: (Math.random()-0.5)*80, y: (Math.random()-0.5)*20, r: 15+Math.random()*20, shadow: Math.random() > 0.8});
                layers[1].items.push(item);
            }
            for (let i = 0; i < sceneryCount; i++) {
                const x=Math.random()*sceneWidth, scale=0.9+Math.random()*0.4, flip=Math.random()>0.5?1:-1, bob=Math.random()*Math.PI*2, r=Math.random(), treeHeight=12*pixelSize*scale;
                if (r<0.6) { layers[2].items.push({ type:'tree', x, y:groundLevel-treeHeight, scale, flip, bob }); }
                else if (r<0.9) { layers[3].items.push({ type:'flower', x, y:groundLevel-10*scale, scale, flip, bob }); }
                else { layers[3].items.push({ type:'heart', x, y:groundLevel, scale:0.8+Math.random()*0.5, bob, isHeart:true }); }
            }
            for (let i=0; i<butterflyCount; i++) { layers[4].items.push({ type:'butterfly', x:Math.random()*sceneWidth, y:groundLevel-Math.random()*height*0.5, scale:1.5+Math.random(), bob:Math.random()*Math.PI*2, flip:Math.random()>0.5?1:-1 }); }
        }
        
        function animate() {
            frameCount++;
            bobAngle = (bobAngle + 0.02) % (Math.PI * 2);
            const sceneWidth = width * sceneWidthMultiplier;

            const skyGradient = ctx.createLinearGradient(0,0,0,height);
            skyGradient.addColorStop(0, palette.sky_top); skyGradient.addColorStop(1, palette.sky_bottom);
            ctx.fillStyle = skyGradient; ctx.fillRect(0, 0, width, height);
            
            const celestialX = width*0.8, celestialY = height*0.15;
            ctx.fillStyle = palette.sun;
            ctx.beginPath(); ctx.arc(celestialX, celestialY, 40, 0, 2*Math.PI); ctx.fill();
            
            layers.forEach(layer => {
                layer.items.forEach(item => {
                    item.x -= layer.speed * 0.016;
                    if (item.x < -item.w - 100) { item.x += sceneWidth + item.w + 100; }
                    else if (item.x < -300) { item.x += sceneWidth + 300; }
                    if (item.isHeart) { 
                        item.y -= 0.5;
                        if(item.y < -50) item.y = height-60;
                    }
                    if (item.isHill) { drawProceduralHills(item); }
                    else if (item.isCloud) { drawProceduralCloud(item); }
                    else if (item.type === 'tree') { drawProceduralTree(item); }
                    else if (item.type) { drawSprite(item); }
                });
            });
            
            ctx.fillStyle = palette.ground; ctx.fillRect(0, height - 60, width, 60);
            ctx.fillStyle = palette.ground_dark; ctx.fillRect(0, height - 50, width, 10);
            
            requestAnimationFrame(animate);
        }

        let resizeTimer;
        function debouncedResize() { clearTimeout(resizeTimer); resizeTimer = setTimeout(resize, 100); }
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            ctx.imageSmoothingEnabled = false; createScene();
        }
        window.addEventListener('resize', debouncedResize);
        resize();
        requestAnimationFrame(animate);
    </script>
</body>
</html>
